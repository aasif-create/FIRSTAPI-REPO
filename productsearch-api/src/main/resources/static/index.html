<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PRODUCT SEARCH ‚Äî Spring Boot API Project</title>

  <!-- Fonts & page CSS (you can keep your home.css) -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="home.css">

  <style>
    /* Star canvas sits behind everything */
    canvas#stars {
      position: fixed;
      inset: 0;
      display: block;
      z-index: -1;       /* behind content */
      pointer-events: none;
    }

    /* Safety: ensure the body has a dark background if home.css doesn't */
    body {
      min-height: 100vh;
      background: radial-gradient(circle at 20% 10%, #081627 0%, #021424 30%, #000814 100%);
      color: #fff;
      margin: 0;
      font-family: "Poppins", system-ui, Arial, sans-serif;
    }

    /* Content tweaks so your hero stays on top */
    .content, .hero, .workflow {
      position: relative;
      z-index: 2;
    }

    /* Optional: small tweak so the flow boxes remain visible over the stars */
    .workflow.card { background: rgba(255,255,255,0.02); padding: 18px; border-radius: 10px; }
  </style>
</head>
<body>

  <!-- Fullscreen star canvas (background) -->
  <canvas id="stars" aria-hidden="true"></canvas>

  <!-- Your original page content -->
  <header class="hero">
    <div class="hero-inner">
      <h1 class="title">FOOD PRODUCTS SEARCH</h1>
      <p class="subtitle">SPRING BOOT API PROJECT</p>
      <p class="tagline"> "A SIMPLE PROJECT TO SHOWCASE HOW AN API WORKS"</p>
      <p class="tagline"> ->Using Food Item Searching Example </p>
    </div>
    <a class="try-btn" href="\fooditem\search.html" role="button" aria-label="Try now ‚Äî go to food search">
      <span class="btn-icon" aria-hidden="true">üçî</span>
      <span class="btn-text">TRY NOW</span>
    </a>
  </header>

  <section class="workflow card">
    <h2 class="workflow-title">Basic Workflow of a product search</h2>
    <div class="workflow-box">
      <section class="workflow card">
        <div class="flow vertical" id="flow-vertical">
          <div class="box">1.User [Searches an item ]</div>
          <div class="arrow vertical">‚Üì</div>
          <div class="box">2.Frontend [Shows typing box & sends search]</div>
          <div class="arrow vertical">‚Üì</div>
          <div class="box">3.API Controller [Passes the request inside]</div>
          <div class="arrow vertical">‚Üì</div>
          <div class="box">4.Service Layer [Asks database for details]</div>
          <div class="arrow vertical">‚Üì</div>
          <div class="box">5.Repository Layer/Data Access Layer [Runs query to fetch data]</div>
          <div class="arrow vertical">‚Üì</div>
          <div class="box">6.Database [Finds matching items]</div>
          <div class="arrow vertical">‚Üì</div>
          <div class="box">7.Repository Layer/Data Access Layer [Sends data back to service]</div>
          <div class="arrow vertical">‚Üì</div>
          <div class="box">8.Service Layer [Collects and organizes results]</div>
          <div class="arrow vertical">‚Üì</div>
          <div class="box">9.API Controller [Sends results back]</div>
          <div class="arrow vertical">‚Üì</div>
          <div class="box">10.Frontend [Displays results to user]</div>
          <div class="arrow vertical">‚Üì</div>
          <div class="box">11.User [Views / selects item]</div>
        </div>
      </section>
    </div>
  </section>

  <!-- Starfield script -->
  <script>
  (function(){
    const canvas = document.getElementById('stars');
    const ctx = canvas.getContext('2d', { alpha: true });
    let w = innerWidth, h = innerHeight;
    const DPR = Math.min(window.devicePixelRatio || 1, 2);

    function setSize(){
      w = innerWidth; h = innerHeight;
      canvas.width = Math.floor(w * DPR);
      canvas.height = Math.floor(h * DPR);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    setSize();

    // Adaptive star count (lower on small screens)
    function calcStarCount(){
      if (Math.min(w,h) < 600) return Math.floor((w*h)/5000); // mobile -> fewer
      return Math.floor((w*h)/2500);
    }

    let STAR_COUNT = calcStarCount();
    let stars = [];
    let mouseX = w/2, mouseY = h/2;
    let running = true;

    function initStars(){
      STAR_COUNT = calcStarCount();
      stars = [];
      const maxR = Math.max(w,h) * 0.6;
      for (let i = 0; i < STAR_COUNT; i++){
        const r = Math.random() * maxR;
        const angle = Math.random() * Math.PI * 2;
        stars.push({
          r,
          angle,
          size: Math.random()*1.6 + 0.3,
          baseAlpha: 0.2 + Math.random()*0.8,
          twinklePhase: Math.random()*Math.PI*2,
          hue: 190 + Math.random()*120 // bluish -> purple
        });
      }
    }
    initStars();

    // handle resize and re-init
    window.addEventListener('resize', () => {
      setSize();
      initStars();
    });

    // mouse/touch parallax
    window.addEventListener('mousemove', (e) => { mouseX = e.clientX; mouseY = e.clientY; });
    window.addEventListener('touchmove', (e) => {
      if (e.touches && e.touches[0]) {
        mouseX = e.touches[0].clientX;
        mouseY = e.touches[0].clientY;
      }
    }, { passive: true });

    // pause when tab hidden (save battery)
    document.addEventListener('visibilitychange', () => {
      running = !document.hidden;
      if (running) requestAnimationFrame(loop);
    });

    // animation loop
    let last = performance.now();
    function loop(now){
      if (!running) return;
      const dt = (now - last) / 1000;
      last = now;
      ctx.clearRect(0,0,w,h);

      // faint nebula background gradient
      const g = ctx.createRadialGradient(w*0.2, h*0.1, 40, w*0.5, h*0.6, Math.max(w,h));
      g.addColorStop(0, 'rgba(40,80,130,0.05)');
      g.addColorStop(0.5, 'rgba(10,20,40,0.18)');
      g.addColorStop(1, 'rgba(0,0,0,0.9)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);

      const centerX = w/2 + (mouseX - w/2) * 0.02;
      const centerY = h/2 + (mouseY - h/2) * 0.02;
      const rotationSpeed = 0.02; // rad/sec

      for (let i = 0; i < stars.length; i++){
        const s = stars[i];
        s.angle += rotationSpeed * dt * (0.5 + (s.r / Math.max(w,h)));
        const alpha = s.baseAlpha * (0.6 + 0.4 * Math.sin((now/300) + s.twinklePhase));
        let x = centerX + Math.cos(s.angle) * s.r;
        let y = centerY + Math.sin(s.angle) * s.r * 0.6;
        const px = (mouseX - w/2) * (s.r / Math.max(w,h)) * 0.02;
        const py = (mouseY - h/2) * (s.r / Math.max(w,h)) * 0.02;
        x += px; y += py;

        // glow
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, s.size*6);
        gradient.addColorStop(0, `hsla(${s.hue}, 90%, 66%, ${alpha})`);
        gradient.addColorStop(0.4, `hsla(${s.hue}, 80%, 55%, ${alpha*0.35})`);
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, s.size*6, 0, Math.PI*2);
        ctx.fill();

        // core
        ctx.fillStyle = `hsla(${s.hue}, 90%, 75%, ${Math.min(1, alpha+0.25)})`;
        ctx.beginPath();
        ctx.arc(x, y, s.size, 0, Math.PI*2);
        ctx.fill();
      }

      requestAnimationFrame(loop);
    }

    // Start animation
    requestAnimationFrame(loop);

    // Expose a tiny API to change vibe from console if needed
    window._starfield = {
      regenerate: () => { initStars(); },
      setLowPowerMode: () => { STAR_COUNT = Math.floor((w*h)/6000); initStars(); }
    };

    // initial focus fix: ensure we keep best DPI transform
    setTimeout(() => { setSize(); initStars(); }, 100);

  })();
  </script>

</body>
</html>
